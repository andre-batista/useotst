import mesa
import numpy as np
from mesa.datacollection import DataCollector

# --- Configuration Constants ---
# Time Unit: Define what each step represents
# Options: "day", "week", "month"
TIME_UNIT = "month"  # Default: cada step = 1 mÃªs
MIN_CAPACITY = 30
MAX_CAPACITY = 99
INITIAL_MIN_CAPACITY = 30
INITIAL_MAX_CAPACITY = 100
CHANCE_OF_TURNOVER = 1  # Percentage

# --- Base Agent Class ---
class BaseTeamMemberAgent(mesa.Agent):
    """A base class for agents with capacity attributes."""
    def __init__(self, model):
        super().__init__(model)

    def clamp_capacity(self, capacity_name):
        """Clamps a given capacity attribute between MIN and MAX values."""
        value = getattr(self, capacity_name)
        if value > MAX_CAPACITY:
            setattr(self, capacity_name, MAX_CAPACITY)
        elif value < MIN_CAPACITY:
            setattr(self, capacity_name, MIN_CAPACITY)

# --- Agent Definitions ---

class ProductAgent(mesa.Agent):
    """
    Represents the evolving software product.
    Its attributes are modified by the actions of the teams.
    """
    def __init__(self, model):
        super().__init__(model)
        # Attribute 1: How complete the product is in terms of features.
        self.feature_completeness = 10.0 

        # Attribute 2: Internal code quality. High quality facilitates new features.
        self.code_quality = 70.0

        # Attribute 3: Accumulated technical debt. High debt hinders development.
        self.technical_debt = 20.0

        # Attribute 4: Number of known bugs. Affects user satisfaction.
        self.bug_count = 5.0

        # Attribute 5: Alignment with market needs.
        self.market_fit = 50.0
        
        # Attribute 6: Market Share (0-100%). Percentage of market captured.
        self.market_share = 0.1
        
        # Attribute 7: Brand Awareness (0-100). Brand recognition in the market.
        self.brand_awareness = 10.0
        
        # Attribute 8: Lead Quality (0-100). Quality of leads generated by marketing.
        self.lead_quality = 30.0
        
        # Attribute 9: Organizational Alignment (0-100). How aligned the teams are.
        self.organizational_alignment = 50.0
        
        # Attribute 10: Organizational Conflict (0-100). Level of organizational conflict.
        self.organizational_conflict = 10.0

    def step(self):
        # The product evolution logic is not here.
        # It will be calculated in the main model (CompanyModel) that orchestrates everything,
        # as it depends on the interaction of all teams.
        pass

class EngineerAgent(BaseTeamMemberAgent):
    def __init__(self, model):
        super().__init__(model)
        self.development_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))
        self.explanation_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))

    def step(self):
        self.clamp_capacity('development_capacity')
        self.clamp_capacity('explanation_capacity')

class SalesAgent(BaseTeamMemberAgent):
    def __init__(self, model):
        super().__init__(model)
        self.selling_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))
        self.understanding_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))

    def step(self):
        self.clamp_capacity('selling_capacity')
        self.clamp_capacity('understanding_capacity')

class MarketingAgent(BaseTeamMemberAgent):
    def __init__(self, model):
        super().__init__(model)
        self.improvement_ideas_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))
        self.publicize_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))

    def step(self):
        self.clamp_capacity('improvement_ideas_capacity')
        self.clamp_capacity('publicize_capacity')

class HumanResourcesAgent(BaseTeamMemberAgent):
    def __init__(self, model):
        super().__init__(model)
        self.coordination_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))
        self.talent_development = float(np.random.randint(30, 100))  # People development
        self.conflict_resolution = float(np.random.randint(30, 100))  # Conflict mediation
        self.hiring_quality = float(np.random.randint(30, 100))       # Hiring quality

    def step(self):
        self.clamp_capacity('coordination_capacity')
        # Clamp new capacities as well
        for cap in ['talent_development', 'conflict_resolution', 'hiring_quality']:
            value = getattr(self, cap)
            setattr(self, cap, float(np.clip(value, MIN_CAPACITY, MAX_CAPACITY)))

class ManagementAgent(BaseTeamMemberAgent):
    def __init__(self, model):
        super().__init__(model)
        self.management_capacity = float(np.random.randint(INITIAL_MIN_CAPACITY, INITIAL_MAX_CAPACITY))
        self.strategic_vision = float(np.random.randint(30, 100))
        self.crisis_management = float(np.random.randint(30, 100))
        self.current_focus = "balanced"  # "engineering", "sales", "marketing", "quality", "balanced"
    
    def assess_situation(self, product, avg_capacities):
        """Assesses the situation and decides where to focus strategically."""
        # Prioritize crises first
        if product.bug_count > 30 and self.crisis_management > 60:
            return "quality"
        elif product.market_share < 5 and product.market_fit > 60:
            return "sales"
        elif product.market_fit < 40:
            return "marketing"
        elif product.technical_debt > 60:
            return "engineering"
        else:
            return "balanced"

    def step(self):
        self.clamp_capacity('management_capacity')

# --- Model Definition ---

class CompanyModel(mesa.Model):
    """
    A unified model representing the entire company, including all teams
    and the product. It orchestrates all interactions.
    """
    def __init__(self, num_engineers, num_sales, num_marketing, num_hr, num_mgmt, params, time_unit="month"):
        super().__init__()
        self.params = params
        
        # Dictionaries for easy access to teams
        self.teams = {
            "engineers": [], "sales": [], "marketing": [], "hr": [], "mgmt": []
        }
        
        # Headcount tracking for cost management
        self.next_agent_id = 0

        # Create the Product Agent
        self.product = ProductAgent(self)
        # Note: The product doesn't need a step in the scheduler, as its logic is passive.
        
        # --- RESOURCE CONSTRAINTS ---
        self.sprint_budget = {
            "engineering": 100.0,
            "sales": 80.0,
            "marketing": 60.0
        }
        
        # --- STRATEGIC DECISIONS ---
        self.strategy = {
            "dev_vs_quality": 0.7,  # 70% dev, 30% quality
            "features_vs_debt": 0.8,  # 80% features, 20% refactoring
            "growth_vs_stability": 0.6  # 60% growth, 40% maintenance
        }
        
        # --- FINANCIAL SYSTEM ---
        self.cash_runway = 100.0  # Months of operation
        self.funding_rounds = 0
        self.revenue = 0.0
        self.burn_rate = 10.0  # Base monthly cost
        
        # --- HISTORY AND METRICS ---
        self.decision_history = []
        self.performance_metrics = {
            "revenue": 0.0,
            "customer_satisfaction": 50.0,
            "team_morale": 70.0
        }
        
        # --- RECOVERY MECHANISMS ---
        self.pivots_remaining = 2

        # Create Team Agents
        agent_counts = {
            EngineerAgent: num_engineers, SalesAgent: num_sales,
            MarketingAgent: num_marketing, HumanResourcesAgent: num_hr,
            ManagementAgent: num_mgmt
        }
        
        for agent_class, count in agent_counts.items():
            # Map agent class to team key
            class_to_team = {
                'EngineerAgent': 'engineers',
                'SalesAgent': 'sales',
                'MarketingAgent': 'marketing',
                'HumanResourcesAgent': 'hr',
                'ManagementAgent': 'mgmt'
            }
            team_key = class_to_team[agent_class.__name__]
            
            for _ in range(count):
                agent = agent_class(self)
                self.teams[team_key].append(agent)
        
        # Track step count manually
        self.step_count = 0
        
        # --- DATA COLLECTOR ---
        self.datacollector = DataCollector(
            model_reporters={
                "Market Fit": lambda m: m.product.market_fit,
                "Feature Completeness": lambda m: m.product.feature_completeness,
                "Technical Debt": lambda m: m.product.technical_debt,
                "Bug Count": lambda m: m.product.bug_count,
                "Code Quality": lambda m: m.product.code_quality,
                "Market Share": lambda m: m.product.market_share,
                "Brand Awareness": lambda m: m.product.brand_awareness,
                "Organizational Alignment": lambda m: m.product.organizational_alignment,
                "Organizational Conflict": lambda m: m.product.organizational_conflict,
                "Cash Runway": lambda m: m.cash_runway,
                "Revenue": lambda m: m.revenue,
                "Team Morale": lambda m: m.performance_metrics.get("team_morale", 0),
                "Customer Satisfaction": lambda m: m.performance_metrics.get("customer_satisfaction", 0),
                "Engineers": lambda m: len(m.teams["engineers"]),
                "Sales": lambda m: len(m.teams["sales"]),
                "Marketing": lambda m: len(m.teams["marketing"]),
            }
        )

    def _get_team_avg_capacity(self, team_key, capacity_name):
        """Helper to calculate the average capacity of a team."""
        team = self.teams[team_key]
        if not team:
            return 0
        return np.average([getattr(agent, capacity_name) for agent in team])
    
    def _update_team_averages(self):
        """Updates all team capacity averages as instance attributes."""
        self.avg_dev_cap = self._get_team_avg_capacity("engineers", "development_capacity")
        self.avg_exp_cap = self._get_team_avg_capacity("engineers", "explanation_capacity")
        self.avg_sell_cap = self._get_team_avg_capacity("sales", "selling_capacity")
        self.avg_und_cap = self._get_team_avg_capacity("sales", "understanding_capacity")
        self.avg_ideas_cap = self._get_team_avg_capacity("marketing", "improvement_ideas_capacity")
        self.avg_pub_cap = self._get_team_avg_capacity("marketing", "publicize_capacity")
        self.avg_coord_cap = self._get_team_avg_capacity("hr", "coordination_capacity")
        self.avg_talent_dev = self._get_team_avg_capacity("hr", "talent_development")
        self.avg_conflict_res = self._get_team_avg_capacity("hr", "conflict_resolution")
        self.avg_mgmt_cap = self._get_team_avg_capacity("mgmt", "management_capacity")
    
    def calculate_priorities(self):
        """Calculates priorities based on multiple factors."""
        priorities = {}
        
        # Feature Priority
        market_demand = (100 - self.product.market_fit) / 100
        feature_gap = 1 - (self.product.feature_completeness / (self.product.feature_completeness + 100))
        priorities["features"] = (market_demand + feature_gap) / 2
        
        # Quality Priority
        debt_urgency = self.product.technical_debt / (self.product.technical_debt + 100)
        bug_urgency = self.product.bug_count / (self.product.bug_count + 30)
        priorities["quality"] = (debt_urgency + bug_urgency) / 2
        
        # Marketing Priority
        market_urgency = (100 - self.product.market_fit) / 100
        priorities["marketing"] = market_urgency
        
        # Normalize priorities
        total = sum(priorities.values())
        if total > 0:
            return {k: v/total for k, v in priorities.items()}
        return priorities
    
    def make_strategic_decision(self):
        """Makes decisions based on the current state of the product."""
        
        # Decision 1: Tech Debt Crisis?
        if self.product.technical_debt > 150:
            self.strategy["features_vs_debt"] = 0.3  # 70% refactoring!
            self.decision_history.append({
                "step": self.step_count,
                "decision": "TECH_DEBT_SPRINT",
                "reason": f"Debt={self.product.technical_debt:.1f}"
            })
        elif self.product.technical_debt < 50:
            self.strategy["features_vs_debt"] = 0.9  # Accelerate features
        
        # Decision 2: Bug Crisis?
        if self.product.bug_count > 30:
            self.strategy["dev_vs_quality"] = 0.4  # 60% on quality
            self.decision_history.append({
                "step": self.step_count,
                "decision": "BUG_FIX_SPRINT",
                "reason": f"Bugs={self.product.bug_count:.1f}"
            })
        
        # Decision 3: Low Market Fit?
        if self.product.market_fit < 40:
            self.sprint_budget["sales"] *= 1.2
            self.sprint_budget["marketing"] *= 1.3
            self.decision_history.append({
                "step": self.step_count,
                "decision": "MARKET_PUSH",
                "reason": f"MarketFit={self.product.market_fit:.1f}"
            })
        
        # Decision 4: Strategic hiring
        avg_eng_cap = self._get_team_avg_capacity("engineers", "development_capacity")
        if len(self.teams["engineers"]) < 20 and avg_eng_cap > 75 and self.cash_runway > 50:
            self.hire_agent(EngineerAgent)
            self.decision_history.append({
                "step": self.step_count,
                "decision": "HIRE_ENGINEER",
                "reason": "Team performing well"
            })
    
    def hire_agent(self, agent_class):
        """Contrata novo agente com capacidade alta."""
        # Map agent class to team key
        class_to_team = {
            'EngineerAgent': 'engineers',
            'SalesAgent': 'sales',
            'MarketingAgent': 'marketing',
            'HumanResourcesAgent': 'hr',
            'ManagementAgent': 'mgmt'
        }
        team_key = class_to_team[agent_class.__name__]
        
        new_agent = agent_class(self)
        
        # Novos contratados comeÃ§am com capacidade moderada-alta
        for cap in [c for c in dir(new_agent) if c.endswith('_capacity') and not callable(getattr(new_agent, c))]:
            setattr(new_agent, cap, float(np.random.randint(60, 85)))
        
        self.teams[team_key].append(new_agent)
        self.burn_rate += 2.0  # Aumenta custo
    
    def calculate_revenue(self):
        """Calculates revenue based on sales and product."""
        # Bugs and debt severely impact revenue
        bug_penalty = 1 / (1 + (self.product.bug_count / 30) ** 2)
        debt_penalty = 1 / (1 + (self.product.technical_debt / 80) ** 1.5)
        
        product_quality = (
            (self.product.market_fit / 100) *
            (self.product.feature_completeness / (self.product.feature_completeness + 50)) *
            bug_penalty *
            debt_penalty
        )
        
        sales_power = self._get_team_avg_capacity("sales", "selling_capacity") * len(self.teams["sales"])
        
        self.revenue = product_quality * sales_power * 0.5
        self.cash_runway += self.revenue - self.burn_rate
    
    def seek_funding(self):
        """Seeks investment when necessary."""
        if self.cash_runway < 20:  # Less than 20 months
            # Chance of getting funding based on metrics
            funding_score = (
                self.product.market_fit / 100 * 0.4 +
                min(self.product.feature_completeness / 100, 1) * 0.3 +
                (1 - min(self.product.technical_debt / 200, 1)) * 0.3
            )
            
            if np.random.random() < funding_score:
                investment = 100 * (1.5 ** self.funding_rounds)
                self.cash_runway += investment
                self.funding_rounds += 1
                
                self.decision_history.append({
                    "step": self.step_count,
                    "decision": "FUNDING_ROUND",
                    "amount": investment
                })
            else:
                # No funding: drastic measures
                self.emergency_layoffs()
    
    def emergency_layoffs(self):
        """Cuts staff to survive."""
        for team_key in ["marketing", "sales"]:
            if len(self.teams[team_key]) > 1:
                agent = self.teams[team_key].pop()
                # Agent is automatically removed from model when no longer referenced
        
        self.burn_rate *= 0.7  # Reduce costs
        
        self.decision_history.append({
            "step": self.step_count,
            "decision": "LAYOFFS",
            "reason": f"Cash runway: {self.cash_runway:.1f}"
        })
    
    def consider_pivot(self):
        """Considers pivoting if failing."""
        
        # Conditions for pivot
        is_failing = (
            self.product.market_fit < 30 and
            self.step_count > 50 and
            self.revenue < 5
        )
        
        if is_failing and self.pivots_remaining > 0:
            self.execute_pivot()
    
    def execute_pivot(self):
        """Executes pivot: keeps team but restarts product."""
        
        # Calculate average team experience
        all_capacities = []
        for team_key in ["engineers", "sales", "marketing"]:
            if self.teams[team_key]:
                for agent in self.teams[team_key]:
                    caps = [getattr(agent, c) for c in dir(agent) 
                           if c.endswith('_capacity') and not callable(getattr(agent, c))]
                    all_capacities.extend(caps)
        
        avg_experience = np.mean(all_capacities) if all_capacities else 50
        
        # Restart product with boost based on experience
        self.product.feature_completeness = 5.0
        self.product.technical_debt = 10.0  # Less debt (they learned)
        self.product.bug_count = 2.0
        self.product.code_quality = 70.0
        self.product.market_fit = 40 + (avg_experience - 50) / 2  # Starts better
        
        self.pivots_remaining -= 1
        
        self.decision_history.append({
            "step": self.step_count,
            "decision": "PIVOT",
            "new_market_fit": self.product.market_fit
        })

    def step(self):
        """Executes one simulation step."""
        
        # Increment step counter
        self.step_count += 1
        
        # --- 0. CHECK FINANCIAL HEALTH ---
        self.calculate_revenue()
        if self.cash_runway < 0:
            return  # Game over - ran out of money
        
        # Check for technical death spiral
        if self.product.technical_debt > 200:
            self.cash_runway = -1  # Force game over - codebase unmaintainable
            return
        
        if self.product.bug_count > 100:
            self.cash_runway = -1  # Force game over - product unusable
            return
        
        if self.step_count % 20 == 0:
            self.seek_funding()
            self.consider_pivot()
        
        # Strategic decisions every 10 steps
        if self.step_count % 10 == 0:
            self.make_strategic_decision()
        
        # Adjust strategy based on priorities
        priorities = self.calculate_priorities()
        self.strategy["dev_vs_quality"] = 1 - priorities["quality"]
        self.sprint_budget["marketing"] = 60 + (priorities["marketing"] * 40)
        
        # --- 1. CALCULATE CAPACITY AVERAGES (CURRENT STATE) ---
        self._update_team_averages()

        # --- 2. PRODUCT EVOLUTION WITH RESOURCE CONSTRAINTS ---
        # Calculate total capacity and apply budget
        total_eng_capacity = self.avg_dev_cap * len(self.teams["engineers"])
        available_capacity = min(total_eng_capacity, self.sprint_budget["engineering"])
        
        # Allocate capacity based on strategy
        dev_allocation = available_capacity * self.strategy["dev_vs_quality"]
        quality_allocation = available_capacity * (1 - self.strategy["dev_vs_quality"])
        
        # Features vs Refactoring
        feature_work = dev_allocation * self.strategy["features_vs_debt"]
        refactor_work = dev_allocation * (1 - self.strategy["features_vs_debt"])
        
        # Quality focus determines how much technical debt/bugs are generated
        # Lower values = more debt/bugs, higher values = less debt/bugs
        # Scale from 0.0 (no quality focus) to 0.8 (high quality focus)
        quality_focus = min(self.avg_exp_cap / 100, 0.8)
        
        # Technical debt acts as a severe brake on development
        # High debt causes exponential slowdown
        debt_drag = 1 / (1 + (self.product.technical_debt / 50) ** 2)
        
        # Bugs also slow down development (need to work around them)
        bug_drag = 1 / (1 + (self.product.bug_count / 20) ** 1.5)
        
        total_drag = debt_drag * bug_drag
        
        # Apply feature work
        self.product.feature_completeness += feature_work * total_drag * self.params['dev_to_features']
        self.product.technical_debt += (1 - quality_focus) * feature_work * self.params['dev_to_debt']
        self.product.bug_count += (1 - quality_focus) * feature_work * self.params['dev_to_bugs']
        
        # Refactoring reduces debt (now parameterized)
        self.product.technical_debt -= refactor_work * self.params['refactor_reduces_debt']
        self.product.code_quality += refactor_work * self.params['refactor_improves_quality']
        
        # Quality work reduces bugs
        self.product.bug_count -= quality_allocation * self.params['quality_reduces_bugs']
        self.product.technical_debt -= quality_allocation * self.params['quality_reduces_debt']
        self.product.code_quality = np.clip(self.product.code_quality + quality_allocation * self.params['quality_improves_code'] - self.product.technical_debt * self.params['debt_degrades_quality'], 0, 100)

        # Sales and Marketing impact Market Fit
        market_insight_effort = (self.avg_und_cap * len(self.teams["sales"]) + self.avg_ideas_cap * len(self.teams["marketing"]))
        self.product.market_fit += market_insight_effort * self.params['insight_to_market_fit']
        
        # --- 3. MANAGE MARKET DYNAMICS ---
        self._manage_market_dynamics()
        
        # --- 4. MANAGE ORGANIZATIONAL HEALTH ---
        self._manage_organizational_health()
        
        # --- 5. MANAGE TURNOVER AND TEAM EVOLUTION ---
        self._manage_turnover_and_hiring()
        self._evolve_teams()
        
        # --- 6. EXECUTE EACH AGENT'S STEP (CLAMP CAPACITIES) ---
        for team in self.teams.values():
            for agent in team:
                agent.step()
        
        # --- 7. UPDATE PERFORMANCE METRICS ---
        self._update_performance_metrics()
        
        # --- 8. COLLECT DATA ---
        self.datacollector.collect(self)
    
    def _manage_finances(self):
        """Calculates revenue, costs, and runway."""
        self.calculate_revenue()
    
    def _evolve_product(self):
        """Placeholder method - logic is already in step()."""
        pass
    
    def _manage_market_dynamics(self):
        """Isolated logic for market dynamics."""
        # Marketing impacts Brand Awareness and Lead Quality
        marketing_effort = self.avg_pub_cap * len(self.teams["marketing"])
        # Brand awareness grows with marketing effort, but has diminishing returns
        awareness_growth = marketing_effort * self.params['marketing_to_awareness'] * (1 - self.product.brand_awareness / 100)
        self.product.brand_awareness += awareness_growth
        
        # Lead quality improves with a good product and good marketing
        product_quality_factor = (self.product.market_fit / 100) * (1 - self.product.bug_count / (self.product.bug_count + 50))
        self.product.lead_quality = np.clip(
            (self.avg_pub_cap + self.avg_ideas_cap) / 2 * product_quality_factor,
            0, 100
        )

        # Market Saturation - Calculate Market Share growth
        # Factors that influence market conquest
        sales_effort = self.avg_sell_cap * len(self.teams["sales"])
        
        # Difficulty of conquering market increases with current market share (law of diminishing returns)
        market_saturation_factor = (1 - self.product.market_share / 100) ** 2
        
        # Brand awareness facilitates market conquest
        awareness_multiplier = (self.product.brand_awareness / 100) * self.params['awareness_boost']
        
        # Lead quality increases sales efficiency
        lead_quality_multiplier = (self.product.lead_quality / 100)
        
        # Product quality remains fundamental
        product_quality_multiplier = (self.product.market_fit / 100) * (self.product.feature_completeness / (self.product.feature_completeness + 50)) * (1 - (self.product.bug_count / (self.product.bug_count + 50)))
        
        # Market share growth
        market_share_growth = (
            sales_effort * 
            market_saturation_factor * 
            (1 + awareness_multiplier) * 
            (1 + lead_quality_multiplier) * 
            product_quality_multiplier * 
            self.params['sales_to_market_share']
        )
        
        self.product.market_share += market_share_growth
        
        # Churn - natural customer loss
        # Churn is higher when the product has bugs or doesn't meet market needs
        churn_base = self.params['base_churn_rate']
        churn_from_bugs = (self.product.bug_count / (self.product.bug_count + 50)) * self.params['churn_from_bugs']
        churn_from_misfit = (1 - self.product.market_fit / 100) * self.params['churn_from_misfit']
        
        total_churn = (churn_base + churn_from_bugs + churn_from_misfit) * self.product.market_share
        self.product.market_share -= total_churn
    
    def _manage_organizational_health(self):
        """Isolated logic for organizational health."""
        # Management improves organizational alignment (strategic)
        alignment_improvement = self.avg_mgmt_cap * self.params['mgmt_to_alignment']
        self.product.organizational_alignment += alignment_improvement
        
        # HR also improves alignment (operational/cultural)
        hr_alignment_contribution = self.avg_coord_cap * self.params['hr_to_alignment']
        self.product.organizational_alignment += hr_alignment_contribution
        
        # Lack of communication deteriorates alignment
        alignment_decay = self.params['alignment_decay']
        self.product.organizational_alignment -= alignment_decay
        
        # Management of organizational conflicts
        # Conflicts arise naturally from misalignment and pressure
        conflict_from_misalignment = (1 - self.product.organizational_alignment / 100) * 0.3
        conflict_from_pressure = (self.product.bug_count / (self.product.bug_count + 50)) * 0.2
        self.product.organizational_conflict += conflict_from_misalignment + conflict_from_pressure
        
        # HR reduces conflicts through mediation
        conflict_resolution_effort = self.avg_conflict_res * self.params['hr_reduces_conflict']
        self.product.organizational_conflict -= conflict_resolution_effort

        # Clean product values to prevent them from becoming negative or above 100
        self.product.technical_debt = max(0, self.product.technical_debt)
        self.product.bug_count = max(0, self.product.bug_count)
        self.product.market_fit = np.clip(self.product.market_fit, 0, 100)
        self.product.market_share = np.clip(self.product.market_share, 0, 100)
        self.product.brand_awareness = np.clip(self.product.brand_awareness, 0, 100)
        self.product.organizational_alignment = np.clip(self.product.organizational_alignment, 0, 100)
        self.product.organizational_conflict = np.clip(self.product.organizational_conflict, 0, 100)
    
    def _calculate_dynamic_turnover(self):
        """Calculates dynamic turnover rate based on HR and conflicts."""
        hr_effectiveness = self.avg_coord_cap / 100
        # Strong HR reduces turnover, weak HR increases it
        dynamic_turnover = self.params['base_turnover_rate'] * (1.5 - hr_effectiveness)
        # Organizational conflicts also increase turnover
        conflict_turnover_multiplier = 1 + (self.product.organizational_conflict / 100) * 0.5
        dynamic_turnover *= conflict_turnover_multiplier
        return dynamic_turnover
    
    def _manage_turnover_and_hiring(self):
        """Manages agent turnover based on dynamic rate."""
        dynamic_turnover = self._calculate_dynamic_turnover()
        
        all_agents = []
        for team in self.teams.values():
            all_agents.extend(team)
        
        for agent in all_agents:
            # Turnover logic using dynamic rate
            if np.random.randint(0, 100) < dynamic_turnover:
                for cap in [c for c in dir(agent) if c.endswith('_capacity') and not callable(getattr(agent, c))]:
                    setattr(agent, cap, np.random.randint(0, INITIAL_MIN_CAPACITY))
    
    def _evolve_teams(self):
        """Evolves the capacities of all agents based on internal and external factors."""
        # Product influence factors
        product_sales_multiplier = (self.product.market_fit / 100) * (self.product.feature_completeness / (self.product.feature_completeness + 50)) * (1 - (self.product.bug_count / (self.product.bug_count + 50)))
        
        # Marketing Support Factor - how much marketing facilitates sales
        marketing_support = (
            (self.product.brand_awareness / 100) * 0.3 +  # Brand awareness helps
            (self.product.lead_quality / 100) * 0.5         # Lead quality helps even more
        )
        
        # Calculate strategic focus of management
        strategic_focus = {"engineering": 0, "sales": 0, "marketing": 0, "quality": 0, "balanced": 0}
        for mgmt_agent in self.teams["mgmt"]:
            avg_caps = {
                "dev": self.avg_dev_cap, "sell": self.avg_sell_cap, 
                "marketing": self.avg_pub_cap, "coord": self.avg_coord_cap
            }
            focus = mgmt_agent.assess_situation(self.product, avg_caps)
            mgmt_agent.current_focus = focus
            strategic_focus[focus] += 1
        
        # Determine dominant focus (majority)
        dominant_focus = max(strategic_focus, key=lambda k: strategic_focus[k]) if self.teams["mgmt"] else "balanced"
        focus_strength = strategic_focus[dominant_focus] / max(len(self.teams["mgmt"]), 1) * self.params['strategic_focus_strength']

        # Logic for each individual agent
        all_agents = []
        for team in self.teams.values():
            all_agents.extend(team)
        
        for agent in all_agents:
            # Talent development by HR (affects all agents)
            if isinstance(agent, (EngineerAgent, SalesAgent, MarketingAgent)):
                if self.avg_talent_dev > 70:
                    talent_boost = (self.avg_talent_dev - 70) / 100 * self.params['hr_talent_boost']
                    for cap in [c for c in dir(agent) if c.endswith('_capacity') and not callable(getattr(agent, c))]:
                        current = getattr(agent, cap)
                        setattr(agent, cap, current + talent_boost)
            
            # Organizational conflicts hurt all teams
            conflict_penalty = (self.product.organizational_conflict / 100) * 0.15
            
            # Specific logic by agent type
            if isinstance(agent, EngineerAgent):
                # Internal influence and from other teams
                if agent.development_capacity < self.avg_dev_cap: agent.development_capacity += self.avg_dev_cap / 10
                if agent.explanation_capacity < self.avg_exp_cap: agent.explanation_capacity += self.avg_exp_cap / 8
                # Influence of Management and HR
                agent.development_capacity += 0.1 if self.avg_mgmt_cap > 70 else -0.1
                agent.explanation_capacity += 0.1 if self.avg_coord_cap > 70 else -0.1
                
                # Penalty for conflicts
                agent.development_capacity -= agent.development_capacity * conflict_penalty
                
                # Strategic focus of management
                if dominant_focus == "engineering":
                    agent.development_capacity += focus_strength
                    agent.explanation_capacity += focus_strength * 0.5
                elif dominant_focus == "quality":
                    agent.explanation_capacity += focus_strength
                
                # Lack of organizational alignment harms collaboration
                alignment_penalty = (1 - self.product.organizational_alignment / 100) * 0.15
                agent.development_capacity -= agent.development_capacity * alignment_penalty

            if isinstance(agent, SalesAgent):
                # Influence of product AND marketing on sales capacity
                base_sales_effect = agent.selling_capacity * product_sales_multiplier * 0.1
                marketing_boost = agent.selling_capacity * marketing_support * 0.05
                natural_decay = agent.selling_capacity * 0.05
                
                agent.selling_capacity += base_sales_effect + marketing_boost - natural_decay
                
                # Market saturation makes sales harder
                # The higher the market share, the harder to sell (fewer prospects available)
                market_difficulty = (self.product.market_share / 100) * 0.03
                agent.selling_capacity -= agent.selling_capacity * market_difficulty
                
                # Strategic focus of management
                if dominant_focus == "sales":
                    agent.selling_capacity += focus_strength
                    agent.understanding_capacity += focus_strength * 0.5
                
                # Lack of alignment harms sales (inconsistent messages)
                alignment_penalty = (1 - self.product.organizational_alignment / 100) * 0.2
                agent.selling_capacity -= agent.selling_capacity * alignment_penalty
                
                # Penalty for conflicts
                agent.selling_capacity -= agent.selling_capacity * conflict_penalty
                
                # Internal influence
                if agent.understanding_capacity < self.avg_und_cap: agent.understanding_capacity += self.avg_und_cap / 10
            
            if isinstance(agent, MarketingAgent):
                # Internal influence
                if agent.publicize_capacity < self.avg_pub_cap: agent.publicize_capacity += self.avg_pub_cap / 10
                if agent.improvement_ideas_capacity < self.avg_ideas_cap: agent.improvement_ideas_capacity += self.avg_ideas_cap / 10
                # Product influence: good product is easier to publicize
                agent.publicize_capacity += (product_sales_multiplier * 0.5)
                # Market influence: low market fit pushes for more ideas
                agent.improvement_ideas_capacity += (1 - self.product.market_fit / 100) * 0.5
                # Influence of Management and HR
                agent.publicize_capacity += 0.1 if self.avg_mgmt_cap > 70 else -0.1
                agent.improvement_ideas_capacity += 0.1 if self.avg_coord_cap > 70 else -0.1
                
                # Strategic focus of management
                if dominant_focus == "marketing":
                    agent.publicize_capacity += focus_strength
                    agent.improvement_ideas_capacity += focus_strength
                
                # Lack of alignment harms marketing (confused message)
                alignment_penalty = (1 - self.product.organizational_alignment / 100) * 0.15
                agent.publicize_capacity -= agent.publicize_capacity * alignment_penalty

            if isinstance(agent, HumanResourcesAgent):
                # Internal influence
                if agent.coordination_capacity < self.avg_coord_cap: agent.coordination_capacity += self.avg_coord_cap / 10
                # Influence of Management
                agent.coordination_capacity += 0.3 if self.avg_mgmt_cap > 70 else -0.3

            if isinstance(agent, ManagementAgent):
                # Internal influence
                if agent.management_capacity < self.avg_mgmt_cap: agent.management_capacity += self.avg_mgmt_cap / 10
                # Influence of HR
                agent.management_capacity += 0.3 if self.avg_coord_cap > 70 else -0.3

    
    def _update_performance_metrics(self):
        """Updates model performance metrics."""
        self.performance_metrics["customer_satisfaction"] = (
            self.product.market_fit * 0.5 +
            (100 - min(self.product.bug_count, 100)) * 0.5
        )
        
        all_caps = []
        for team_key in ["engineers", "sales", "marketing"]:
            if self.teams[team_key]:
                for agent in self.teams[team_key]:
                    caps = [getattr(agent, c) for c in dir(agent) if c.endswith('_capacity') and not callable(getattr(agent, c))]
                    all_caps.extend(caps)
        
        self.performance_metrics["team_morale"] = float(np.mean(all_caps)) if all_caps else 50.0
        self.performance_metrics["revenue"] = float(self.revenue)

# --- Helper Functions ---

def get_default_params():
    """Returns a dictionary with default model parameters."""
    return {
        'dev_to_features': 0.01,
        'dev_to_debt': 0.05,  # 10x increase - debt accumulates faster
        'dev_to_bugs': 0.03,  # 15x increase - bugs appear more frequently
        'quality_reduces_bugs': 0.02,  # 4x increase - QA is more effective
        'quality_reduces_debt': 0.015,  # 5x increase - refactoring is more effective
        'quality_improves_code': 0.005,  # 5x increase
        'refactor_reduces_debt': 0.04,  # 4x increase - refactoring has meaningful impact
        'refactor_improves_quality': 0.02,  # 2x increase
        'debt_degrades_quality': 0.015,  # 1.5x increase - debt hurts quality more
        'insight_to_market_fit': 0.001,
        'marketing_to_awareness': 0.05,
        'awareness_boost': 0.5,
        'sales_to_market_share': 0.01,
        'base_churn_rate': 0.5,
        'churn_from_bugs': 2.0,
        'churn_from_misfit': 1.5,
        'mgmt_to_alignment': 0.05,
        'hr_to_alignment': 0.03,
        'alignment_decay': 0.5,
        'hr_reduces_conflict': 0.05,
        'base_turnover_rate': 2.0,
        'hr_talent_boost': 0.3,
        'strategic_focus_strength': 2.0,
    }

# --- Simulation Function ---

def run_simulation(num_engineers=10, num_sales=5, num_marketing=3, num_hr=1, num_mgmt=1, 
                   steps=200, params=None, verbose=False):
    """
    Executes a company simulation with the given parameters.
    
    Parameters:
    -----------
    num_engineers : int
        Number of engineer agents (default: 10)
    num_sales : int
        Number of sales agents (default: 5)
    num_marketing : int
        Number of marketing agents (default: 3)
    num_hr : int
        Number of HR agents (default: 1)
    num_mgmt : int
        Number of management agents (default: 1)
    steps : int
        Number of simulation steps to run (default: 200)
    params : dict
        Model parameters dictionary. If None, uses default parameters.
    verbose : bool
        If True, prints progress information (default: False)
    
    Returns:
    --------
    dict
        A dictionary containing:
        - 'model': The CompanyModel instance
        - 'data': DataFrame with collected metrics over time
        - 'final_state': Dictionary with final metrics
        - 'game_over': Boolean indicating if simulation ended early
        - 'game_over_step': Step at which game over occurred (if applicable)
    """
    # Default parameters if none provided
    if params is None:
        params = get_default_params()
    
    # Create model
    company = CompanyModel(num_engineers, num_sales, num_marketing, num_hr, num_mgmt, params)
    
    if verbose:
        print(f"Starting simulation with {num_engineers} engineers, {num_sales} sales, {num_marketing} marketing")
    
    # Run simulation
    game_over = False
    game_over_step = None
    
    for i in range(steps):
        company.step()
        
        # Check for game over
        if company.cash_runway < 0:
            game_over = True
            game_over_step = i
            if verbose:
                print(f"Game Over at step {i}: Cash runway depleted!")
            break
        
        # Progress updates
        if verbose and i % 50 == 0:
            print(f"Step {i}: Market Fit={company.product.market_fit:.1f}, Cash={company.cash_runway:.1f}")
    
    # Collect results
    data = company.datacollector.get_model_vars_dataframe()
    
    final_state = {
        'market_fit': company.product.market_fit,
        'market_share': company.product.market_share,
        'feature_completeness': company.product.feature_completeness,
        'technical_debt': company.product.technical_debt,
        'bug_count': company.product.bug_count,
        'code_quality': company.product.code_quality,
        'brand_awareness': company.product.brand_awareness,
        'organizational_alignment': company.product.organizational_alignment,
        'organizational_conflict': company.product.organizational_conflict,
        'cash_runway': company.cash_runway,
        'revenue': company.revenue,
        'funding_rounds': company.funding_rounds,
        'pivots_used': 2 - company.pivots_remaining,
        'total_decisions': len(company.decision_history),
        'team_size': {
            'engineers': len(company.teams['engineers']),
            'sales': len(company.teams['sales']),
            'marketing': len(company.teams['marketing']),
            'hr': len(company.teams['hr']),
            'management': len(company.teams['mgmt'])
        }
    }
    
    if verbose:
        print("\nSimulation Complete!")
        print(f"Final Market Fit: {final_state['market_fit']:.1f}")
        print(f"Final Market Share: {final_state['market_share']:.1f}%")
        print(f"Final Cash Runway: {final_state['cash_runway']:.1f} months")
    
    return {
        'model': company,
        'data': data,
        'final_state': final_state,
        'game_over': game_over,
        'game_over_step': game_over_step
    }

# --- Execution Example ---

if __name__ == "__main__":

    print("=== SOFTWARE COMPANY SIMULATION ===\n")
    
    # Run simulation using the run_simulation function
    result = run_simulation(
        num_engineers=10,
        num_sales=5,
        num_marketing=3,
        num_hr=1,
        num_mgmt=1,
        steps=200,
        verbose=False
    )
    
    # Get results
    company = result['model']
    data = result['data']
    final_state = result['final_state']
    
    # Print summary statistics every 20 steps
    print(f"Engenheiros: {final_state['team_size']['engineers']}, "
          f"Vendas: {final_state['team_size']['sales']}, "
          f"Marketing: {final_state['team_size']['marketing']}\n")
    
    # Show progression at key steps
    for i in range(0, len(data), 20):
        if i >= len(data):
            break
            
        print(f"\n{'='*60}")
        print(f"STEP {i}")
        print(f"{'='*60}")
        print(f"\nðŸ“¦ PRODUCT:")
        print(f"  Market Fit: {data.iloc[i]['Market Fit']:.1f}/100")
        print(f"  Features: {data.iloc[i]['Feature Completeness']:.1f}")
        print(f"  Technical Debt: {data.iloc[i]['Technical Debt']:.1f}")
        print(f"  Bugs: {data.iloc[i]['Bug Count']:.1f}")
        print(f"  Code Quality: {data.iloc[i]['Code Quality']:.1f}/100")
        
        print(f"\nðŸ’° FINANCE:")
        print(f"  Cash Runway: {data.iloc[i]['Cash Runway']:.1f} months")
        print(f"  Revenue: ${data.iloc[i]['Revenue']:.1f}/step")
        
        print(f"\nðŸ‘¥ TEAM:")
        print(f"  Engineers: {int(data.iloc[i]['Engineers'])}")
        print(f"  Sales: {int(data.iloc[i]['Sales'])}")
        print(f"  Marketing: {int(data.iloc[i]['Marketing'])}")
        print(f"  Team Morale: {data.iloc[i]['Team Morale']:.1f}/100")
    
    # Print final results
    print(f"\n\n{'='*60}")
    if result['game_over']:
        print(f"ðŸ’€ GAME OVER at step {result['game_over_step']}")
    else:
        print("SIMULATION COMPLETE")
    print(f"\nðŸ“Š FINAL RESULTS:")
    print(f"  Market Fit: {final_state['market_fit']:.1f}/100")
    print(f"  Market Share: {final_state['market_share']:.1f}%")
    print(f"  Feature Completeness: {final_state['feature_completeness']:.1f}")
    print(f"  Technical Debt: {final_state['technical_debt']:.1f}")
    print(f"  Bug Count: {final_state['bug_count']:.1f}")
    print(f"  Code Quality: {final_state['code_quality']:.1f}/100")
    print(f"  Brand Awareness: {final_state['brand_awareness']:.1f}/100")
    print(f"  Organizational Alignment: {final_state['organizational_alignment']:.1f}/100")
    print(f"  Organizational Conflict: {final_state['organizational_conflict']:.1f}/100")
    print(f"  Customer Satisfaction: {data.iloc[-1]['Customer Satisfaction']:.1f}/100")
    print(f"{'='*60}")
    print(f"Final Market Fit: {final_state['market_fit']:.1f}")
    print(f"Final Market Share: {final_state['market_share']:.1f}%")
    print(f"Final Cash Runway: {final_state['cash_runway']:.1f}")
    print(f"Total Decisions Made: {final_state['total_decisions']}")
    print(f"Funding Rounds: {final_state['funding_rounds']}")
    print(f"Pivots Used: {final_state['pivots_used']}/2")
